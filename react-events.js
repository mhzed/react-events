// Generated by CoffeeScript 1.8.0

/*

A react mix-in for handling/routing events.
Event can be specified with ip address like name, using . to separate tokens.
Handler can then be registered to listen of event by exact match, or a simple pattern where * match
any single token.

Example:

  render : ()->
    React.DOM.div null,
      React.DOM.div { onClick : @h('button.new') }
      React.DOM.div { onClick : @h('button.open') }
      React.DOM.div { onClick : @h('cb.x.y') }
      React.DOM.div { onClick : @h('cb.z.y') }

  myComp.on "button.new" (p,e,m)->  # p is 'button.new', e is react event, m is ''
  myComp.on "button.*" (p,e,m)->    # p is 'button.new' or 'button.open', e is react event, m is 'new' or 'open'
  myComp.on "cb.*.y" (p,e,m)->      # p is 'cb.x.y' or 'cb.z.y', e is react event, m is x or z
  myComp.on "cb.*.*" (p,e,m)->      # p is 'cb.x.y' or 'cb.z.y', e is react event, m is x.y or z.y
  myComp.on "cb.*" (p,e,m)->        # no match, never called, * matches a single token only
 */

(function() {
  var evRouterMixin,
    __slice = [].slice;

  module.exports = evRouterMixin = {
    on: function(name, cb) {
      var last, path, t, tree, _i, _j, _len, _ref;
      _ref = name.split("."), path = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), last = _ref[_i++];
      tree = this._evRoutes || (this._evRoutes = {});
      for (_j = 0, _len = path.length; _j < _len; _j++) {
        t = path[_j];
        tree = tree[t] || (tree[t] = {
          __ehs: []
        });
      }
      tree[last] || (tree[last] = {
        __ehs: []
      });
      return tree[last].__ehs.push(cb);
    },
    h: function(param) {
      return this._evClick.bind(this, param);
    },
    _evClick: function(param, event) {
      var name, walk;
      name = 'string' === typeof param ? param : param.name;
      walk = (function(_this) {
        return function(toks, tree, match) {
          var h, t, _i, _j, _len, _len1, _ref, _ref1, _results;
          t = toks[0];
          if (toks.length === 1) {
            _ref = (tree[t] || _this.__l).__ehs;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              h = _ref[_i];
              h(param, event, match.slice(0, -1));
            }
            _ref1 = (tree['*'] || _this.__l).__ehs;
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              h = _ref1[_j];
              _results.push(h(param, event, match + t));
            }
            return _results;
          } else {
            if (t in tree) {
              walk(toks.slice(1), tree[t], match);
            }
            if ('*' in tree) {
              return walk(toks.slice(1), tree['*'], match + t + ".");
            }
          }
        };
      })(this);
      if (this._evRoutes) {
        return walk(name.split("."), this._evRoutes, '');
      }
    },
    __l: {
      __ehs: []
    }
  };

}).call(this);

//# sourceMappingURL=react-events.js.map
